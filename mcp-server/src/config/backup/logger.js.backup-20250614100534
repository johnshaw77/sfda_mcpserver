/**
 * çµ±ä¸€ä¼æ¥­ç´šæ—¥èªŒç³»çµ±
 * åŒæ™‚æ”¯æ´æª”æ¡ˆæ—¥èªŒå’Œ SQLite æŸ¥è©¢
 * ç¬¦åˆç›£æ§èˆ‡å¯è§€æ¸¬æ€§éœ€æ±‚
 */

import fs from "fs";
import path from "path";
import sqlite3 from "sqlite3";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * ä¼æ¥­ç´šæ··åˆå¼æ—¥èªŒç³»çµ±
 * åŒæ™‚æ”¯æ´æª”æ¡ˆæ—¥èªŒå’Œ SQLite æŸ¥è©¢
 */
class Logger {
  constructor(options = {}) {
    // æ—¥èªŒç­‰ç´šå®šç¾© - ç¢ºä¿åœ¨ä½¿ç”¨å‰å…ˆå®šç¾©
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3,
      trace: 4,
    };

    // ç¾åœ¨å¯ä»¥å®‰å…¨ä½¿ç”¨ parseLogLevel æ–¹æ³•
    this.logLevel = this.parseLogLevel(
      options.logLevel || process.env.LOG_LEVEL || "info",
    );
    this.logDir = options.logDir || path.join(__dirname, "../logs");
    this.dbPath = options.dbPath || path.join(this.logDir, "logs.db");
    this.maxFileSize = options.maxFileSize || 50 * 1024 * 1024; // 50MB
    this.maxFiles = options.maxFiles || 10;
    this.serviceName = options.serviceName || "mcp-server";
    this.environment =
      options.environment || process.env.NODE_ENV || "development";
    this.useDatabase = options.useDatabase !== false; // é è¨­å•Ÿç”¨è³‡æ–™åº«

    // åˆå§‹åŒ–æª”æ¡ˆç›¸é—œ
    this.ensureLogDirectory();
    this.initLogFiles();

    // è³‡æ–™åº«åˆå§‹åŒ–å°‡åœ¨ init() æ–¹æ³•ä¸­é€²è¡Œï¼Œé¿å…é‡è¤‡åˆå§‹åŒ–
  }

  parseLogLevel(level) {
    if (!level) return "info";

    const normalizedLevel = level.toLowerCase();
    // ä½¿ç”¨æ›´å¥å£¯çš„æ–¹å¼æª¢æŸ¥æ—¥èªŒç­‰ç´šæ˜¯å¦æœ‰æ•ˆ
    const validLevels = ["error", "warn", "info", "debug", "trace"];
    return validLevels.includes(normalizedLevel) ? normalizedLevel : "info";
  }

  ensureLogDirectory() {
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }

  initLogFiles() {
    this.logFiles = {
      combined: path.join(this.logDir, "combined.log"),
      error: path.join(this.logDir, "error.log"),
      tool: path.join(this.logDir, "tool-calls.log"),
      access: path.join(this.logDir, "access.log"),
    };
  }

  async initDatabase() {
    try {
      this.db = new sqlite3.Database(this.dbPath);
      await this.createTables();
      console.log("âœ… SQLite æ—¥èªŒè³‡æ–™åº«å·²åˆå§‹åŒ–");
    } catch (error) {
      console.error("âŒ SQLite åˆå§‹åŒ–å¤±æ•—:", error);
      this.useDatabase = false;
    }
  }

  async createTables() {
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        level TEXT NOT NULL,
        service TEXT NOT NULL,
        environment TEXT NOT NULL,
        message TEXT NOT NULL,
        category TEXT,
        tool_name TEXT,
        duration INTEGER,
        success INTEGER,
        client_id TEXT,
        method TEXT,
        url TEXT,
        status_code INTEGER,
        ip TEXT,
        user_agent TEXT,
        meta TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON logs(timestamp);
      CREATE INDEX IF NOT EXISTS idx_logs_level ON logs(level);
      CREATE INDEX IF NOT EXISTS idx_logs_category ON logs(category);
      CREATE INDEX IF NOT EXISTS idx_logs_tool_name ON logs(tool_name);
      CREATE INDEX IF NOT EXISTS idx_logs_created_at ON logs(created_at);
    `;

    return new Promise((resolve, reject) => {
      this.db.exec(createTableSQL, err => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  /**
   * åˆå§‹åŒ–æ–¹æ³•ï¼Œç”¨æ–¼åœ¨ç³»çµ±å•Ÿå‹•æ™‚éåŒæ­¥åˆå§‹åŒ–æ—¥èªŒç³»çµ±
   * é€™å€‹æ–¹æ³•å¯ä»¥åœ¨ server.js ä¸­è¢« await èª¿ç”¨
   */
  async init() {
    // é¿å…é‡è¤‡åˆå§‹åŒ–çš„æ¨™è¨˜
    if (this._initialized) {
      console.log("ğŸ“ æ—¥èªŒç³»çµ±å·²ç¶“åˆå§‹åŒ–éï¼Œè·³é");
      return this;
    }

    // ç¢ºä¿ç›®éŒ„å’Œæ–‡ä»¶å·²ç¶“æ­£ç¢ºåˆå§‹åŒ–
    this.ensureLogDirectory();
    this.initLogFiles();

    // åˆå§‹åŒ–è³‡æ–™åº«ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
    if (this.useDatabase) {
      await this.initDatabase();
      console.log("ğŸ“ æ—¥èªŒç³»çµ±å·²å®Œå…¨åˆå§‹åŒ–");
    }

    this._initialized = true;
    return this;
  }

  /**
   * å»ºç«‹çµæ§‹åŒ–æ—¥èªŒæ¢ç›®
   */
  createLogEntry(level, message, meta = {}) {
    const timestamp = new Date().toISOString();
    return {
      timestamp,
      level: level.toUpperCase(),
      service: this.serviceName,
      environment: this.environment,
      message,
      pid: process.pid,
      ...meta,
    };
  }

  /**
   * æª¢æŸ¥æ˜¯å¦æ‡‰è©²è¨˜éŒ„æ­¤ç­‰ç´š
   */
  shouldLog(level) {
    return this.levels[level] <= this.levels[this.logLevel];
  }

  /**
   * é›™é‡å¯«å…¥ï¼šæª”æ¡ˆ + è³‡æ–™åº«
   */
  async writeLog(logEntry, logType = "combined") {
    if (!this.shouldLog(logEntry.level.toLowerCase())) {
      return;
    }

    // 1. å¯«å…¥æª”æ¡ˆ (åŒæ­¥ï¼Œç¢ºä¿å³æ™‚æ€§)
    this.writeToFile(logEntry, logType);

    // 2. å¯«å…¥è³‡æ–™åº« (éåŒæ­¥ï¼Œä¸é˜»å¡ä¸»è¦æµç¨‹)
    if (this.useDatabase) {
      this.writeToDatabase(logEntry).catch(error => {
        console.error("è³‡æ–™åº«å¯«å…¥å¤±æ•—:", error);
      });
    }
  }

  /**
   * å¯«å…¥æª”æ¡ˆ (JSON æ ¼å¼)
   */
  writeToFile(logEntry, logType) {
    const logLine = JSON.stringify(logEntry) + "\n";
    const fileName = this.logFiles[logType] || this.logFiles.combined;

    try {
      this.rotateLogIfNeeded(fileName);
      fs.appendFileSync(fileName, logLine);

      if (this.environment === "development") {
        this.consoleOutput(logEntry);
      }
    } catch (error) {
      console.error("æª”æ¡ˆæ—¥èªŒå¯«å…¥å¤±æ•—:", error);
    }
  }

  /**
   * å¯«å…¥è³‡æ–™åº«
   */
  async writeToDatabase(logEntry) {
    if (!this.db) return;

    const sql = `
      INSERT INTO logs (
        timestamp, level, service, environment, message, category,
        tool_name, duration, success, client_id, method, url,
        status_code, ip, user_agent, meta
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const params = [
      logEntry.timestamp,
      logEntry.level,
      logEntry.service,
      logEntry.environment,
      logEntry.message,
      logEntry.category || null,
      logEntry.toolName || null,
      logEntry.duration || null,
      logEntry.success !== undefined ? (logEntry.success ? 1 : 0) : null,
      logEntry.clientId || null,
      logEntry.method || null,
      logEntry.url || null,
      logEntry.statusCode || null,
      logEntry.ip || null,
      logEntry.userAgent || null,
      JSON.stringify(logEntry.meta || {}),
    ];

    return new Promise((resolve, reject) => {
      this.db.run(sql, params, function (err) {
        if (err) reject(err);
        else resolve(this.lastID);
      });
    });
  }

  /**
   * æ§åˆ¶å°è¼¸å‡º (é–‹ç™¼ç’°å¢ƒ)
   */
  consoleOutput(logEntry) {
    const colors = {
      ERROR: "\x1b[31m",
      WARN: "\x1b[33m",
      INFO: "\x1b[36m",
      DEBUG: "\x1b[90m",
      TRACE: "\x1b[37m",
    };

    const resetColor = "\x1b[0m";
    const color = colors[logEntry.level] || "";

    console.log(
      `${color}[${logEntry.timestamp}] ${logEntry.level}: ${logEntry.message}${resetColor}`,
    );
  }

  /**
   * æ—¥èªŒè¼ªè½‰æ©Ÿåˆ¶
   */
  rotateLogIfNeeded(fileName) {
    if (!fs.existsSync(fileName)) return;

    const stats = fs.statSync(fileName);
    if (stats.size < this.maxFileSize) return;

    const baseFileName = fileName.replace(".log", "");
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const rotatedFileName = `${baseFileName}.${timestamp}.log`;

    try {
      fs.renameSync(fileName, rotatedFileName);
      this.cleanupOldLogs(baseFileName);

      this.info("æ—¥èªŒæª”æ¡ˆå·²è¼ªè½‰", {
        originalFile: fileName,
        rotatedFile: rotatedFileName,
        fileSize: stats.size,
      });
    } catch (error) {
      console.error("æ—¥èªŒè¼ªè½‰å¤±æ•—:", error);
    }
  }

  /**
   * æ¸…ç†èˆŠæ—¥èªŒæª”æ¡ˆ
   */
  cleanupOldLogs(baseFileName) {
    const logDir = path.dirname(baseFileName);
    const baseName = path.basename(baseFileName);

    try {
      const files = fs
        .readdirSync(logDir)
        .filter(file => file.startsWith(baseName) && file.includes(".log"))
        .map(file => ({
          name: file,
          path: path.join(logDir, file),
          stat: fs.statSync(path.join(logDir, file)),
        }))
        .sort((a, b) => b.stat.mtime - a.stat.mtime);

      if (files.length > this.maxFiles) {
        const filesToDelete = files.slice(this.maxFiles);
        filesToDelete.forEach(file => {
          fs.unlinkSync(file.path);
        });
      }
    } catch (error) {
      console.error("æ¸…ç†èˆŠæ—¥èªŒæª”æ¡ˆå¤±æ•—:", error);
    }
  }

  // åŸºæœ¬æ—¥èªŒæ–¹æ³•
  async error(message, meta = {}) {
    const logEntry = this.createLogEntry("error", message, meta);
    await this.writeLog(logEntry, "error");
    await this.writeLog(logEntry, "combined");
  }

  async warn(message, meta = {}) {
    const logEntry = this.createLogEntry("warn", message, meta);
    await this.writeLog(logEntry, "combined");
  }

  async info(message, meta = {}) {
    const logEntry = this.createLogEntry("info", message, meta);
    await this.writeLog(logEntry, "combined");
  }

  async debug(message, meta = {}) {
    const logEntry = this.createLogEntry("debug", message, meta);
    await this.writeLog(logEntry, "combined");
  }

  async trace(message, meta = {}) {
    const logEntry = this.createLogEntry("trace", message, meta);
    await this.writeLog(logEntry, "combined");
  }

  // ç‰¹æ®Šç”¨é€”æ—¥èªŒæ–¹æ³•
  async toolCall(toolName, params, result, duration, clientId = null) {
    const logEntry = this.createLogEntry("info", "å·¥å…·èª¿ç”¨", {
      category: "tool-call",
      toolName,
      params: this.sanitizeParams(params),
      success: !result.error,
      duration,
      clientId,
    });
    await this.writeLog(logEntry, "tool");
  }

  async apiAccess(req, res, duration) {
    const logEntry = this.createLogEntry("info", "API å­˜å–", {
      category: "api-access",
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      userAgent: req.headers ? req.headers["user-agent"] : undefined,
      ip: req.ip,
      duration,
    });
    await this.writeLog(logEntry, "access");
  }

  async systemEvent(event, data = {}) {
    const logEntry = this.createLogEntry("info", "ç³»çµ±äº‹ä»¶", {
      category: "system-event",
      event,
      data,
    });
    await this.writeLog(logEntry, "combined");
  }

  /**
   * æ¸…ç†æ•æ„Ÿåƒæ•¸
   */
  sanitizeParams(params) {
    const sanitized = { ...params };
    const sensitiveFields = ["password", "token", "apiKey", "secret"];

    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = "***";
      }
    });

    return sanitized;
  }

  /**
   * SQL æŸ¥è©¢ä»‹é¢
   */
  async queryLogs(options = {}) {
    if (!this.useDatabase || !this.db) {
      throw new Error("è³‡æ–™åº«æŸ¥è©¢ä¸å¯ç”¨");
    }

    const {
      level,
      category,
      toolName,
      startTime,
      endTime,
      limit = 100,
      offset = 0,
    } = options;

    let sql = "SELECT * FROM logs WHERE 1=1";
    const params = [];

    if (level) {
      sql += " AND level = ?";
      params.push(level.toUpperCase());
    }

    if (category) {
      sql += " AND category = ?";
      params.push(category);
    }

    if (toolName) {
      sql += " AND tool_name = ?";
      params.push(toolName);
    }

    if (startTime) {
      sql += " AND timestamp >= ?";
      params.push(startTime);
    }

    if (endTime) {
      sql += " AND timestamp <= ?";
      params.push(endTime);
    }

    sql += " ORDER BY timestamp DESC LIMIT ? OFFSET ?";
    params.push(limit, offset);

    return new Promise((resolve, reject) => {
      this.db.all(sql, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }

  /**
   * ç²å–çµ±è¨ˆè³‡è¨Š
   */
  async getStats() {
    const fileStats = this.getFileStats();

    if (this.useDatabase && this.db) {
      const dbStats = await this.getDatabaseStats();
      return { ...fileStats, database: dbStats };
    }

    return fileStats;
  }

  getFileStats() {
    const stats = {};

    Object.entries(this.logFiles).forEach(([type, filePath]) => {
      try {
        if (fs.existsSync(filePath)) {
          const fileStats = fs.statSync(filePath);
          stats[type] = {
            size: fileStats.size,
            lastModified: fileStats.mtime,
            exists: true,
          };
        } else {
          stats[type] = { exists: false };
        }
      } catch (error) {
        stats[type] = { error: error.message };
      }
    });

    return {
      currentLogLevel: this.logLevel,
      logDirectory: this.logDir,
      maxFileSize: this.maxFileSize,
      maxFiles: this.maxFiles,
      files: stats,
    };
  }

  async getDatabaseStats() {
    if (!this.useDatabase || !this.db) {
      return null;
    }

    const queries = [
      "SELECT COUNT(*) as totalLogs FROM logs",
      "SELECT level, COUNT(*) as count FROM logs GROUP BY level",
      "SELECT category, COUNT(*) as count FROM logs WHERE category IS NOT NULL GROUP BY category",
      "SELECT tool_name, COUNT(*) as count FROM logs WHERE tool_name IS NOT NULL GROUP BY tool_name ORDER BY count DESC LIMIT 10",
    ];

    try {
      const results = await Promise.all(
        queries.map(
          query =>
            new Promise((resolve, reject) => {
              this.db.all(query, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
              });
            }),
        ),
      );

      return {
        totalLogs: results[0][0].totalLogs,
        logsByLevel: results[1],
        logsByCategory: results[2],
        topTools: results[3],
      };
    } catch (error) {
      console.error("ç²å–è³‡æ–™åº«çµ±è¨ˆå¤±æ•—:", error);
      return { error: error.message };
    }
  }

  /**
   * è¨­å®šæ—¥èªŒç­‰ç´š
   */
  setLogLevel(level) {
    const normalizedLevel = this.parseLogLevel(level);
    this.logLevel = normalizedLevel;
    this.info("æ—¥èªŒç­‰ç´šå·²æ›´æ–°", { newLevel: normalizedLevel });
  }

  /**
   * æ‰‹å‹•è§¸ç™¼æ—¥èªŒè¼ªè½‰
   */
  rotateAllLogs() {
    Object.values(this.logFiles).forEach(filePath => {
      this.rotateLogIfNeeded(filePath);
    });
    this.info("æ‰‹å‹•æ—¥èªŒè¼ªè½‰å·²å®Œæˆ");
  }

  /**
   * é—œé–‰æ—¥èªŒç³»çµ±
   */
  async close() {
    if (this.db) {
      return new Promise(resolve => {
        this.db.close(err => {
          if (err) {
            console.error("é—œé–‰è³‡æ–™åº«å¤±æ•—:", err);
          } else {
            console.log("è³‡æ–™åº«é€£æ¥å·²é—œé–‰");
          }
          resolve();
        });
      });
    }
  }
}

// å»ºç«‹å…¨åŸŸæ—¥èªŒå¯¦ä¾‹
const logger = new Logger({
  serviceName: "mcp-server",
  logLevel: process.env.LOG_LEVEL || "info",
  environment: process.env.NODE_ENV || "development",
  useDatabase: process.env.USE_DATABASE_LOGGING !== "false",
});

// ç‚ºäº†å‘å¾Œå…¼å®¹ï¼Œæ·»åŠ èˆ‡èˆŠç‰ˆ Winston logger ç›¸åŒçš„æ–¹æ³•
logger.verbose = logger.trace;

// å°å‡ºæ—¥èªŒå¯¦ä¾‹
export default logger;
